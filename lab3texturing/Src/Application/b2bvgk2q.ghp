#include "texture_objects.h"

// Base class implementation **************************

TexturedObject::TexturedObject(LPDIRECT3DDEVICE9 device) {
    d3dDevice = device;
    vbuffer = NULL;
    pTexture = NULL;
    triangleCount = 0;
}

TexturedObject::~TexturedObject() {
    vbuffer->Release();
    pTexture->Release();
}

void TexturedObject::prepare() {
    d3dDevice->SetFVF(TEXTURE_VERTEX_FVF);
    d3dDevice->SetRenderState(D3DRS_LIGHTING, false);
    d3dDevice->SetTexture(0, pTexture);
}

void TexturedObject::render() {
    d3dDevice->SetStreamSource(0, vbuffer, 0, sizeof(TEXTURE_VERTEX_WITH_NORMAL));
    d3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, triangleCount);
}

void TexturedObject::setVertices(const std::vector<TEXTURE_VERTEX_WITH_NORMAL> vertices) {
    triangleCount = vertices.size() / 3;

    d3dDevice->CreateVertexBuffer(sizeof(TEXTURE_VERTEX_WITH_NORMAL)* vertices.size(),
                                 D3DUSAGE_WRITEONLY,
                                 TEXTURE_VERTEX_FVF,
                                 D3DPOOL_DEFAULT,
                                 &vbuffer,
                                 NULL);

    VOID* pVoid;

    vbuffer->Lock(0, 0, (void**)&pVoid, 0);
    memcpy(pVoid, vertices.data(), sizeof(TEXTURE_VERTEX_WITH_NORMAL)* vertices.size());
    vbuffer->Unlock();
}


// Square
Square::Square(LPDIRECT3DDEVICE9 device, const D3DXVECTOR3& vect, float size, std::vector<LPCWSTR> mipmapFilenames) 
: TexturedObject(device) {

    std::vector<TEXTURE_VERTEX_WITH_NORMAL> vertices;
    D3DXVECTOR3 normal = vect;
    D3DXVec3Normalize(&normal, &normal);

    const int n = 30;
    const float min = -size / 2;
    const float max = +size / 2;
    const float step = size / n;

    D3DXVECTOR3 e1(1.0f, -normal.x / normal.y, 0.0f);
    D3DXVECTOR3 e2(1.0f, normal.y / normal.x, -(normal.x * normal.x + normal.y * normal.y) / (normal.x * normal.z));

    D3DXVec3Normalize(&e1, &e1);
    D3DXVec3Normalize(&e2, &e2);

    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            D3DXVECTOR3 u1 = e1 * (float)(i - n / 2) * step + e2 * (float)(j - n / 2) * step + vect;
            D3DXVECTOR3 u2 = e1 * (float)(i + 1 - n / 2) * step + e2 * (float)(j - n / 2) * step + vect;
            D3DXVECTOR3 u3 = e1 * (float)(i - n / 2) * step + e2 * (float)(j + 1 - n / 2) * step + vect;
            D3DXVECTOR3 u4 = e1 * (float)(i + 1 - n / 2) * step + e2 * (float)(j + 1 - n / 2) * step + vect;

            TEXTURE_VERTEX_WITH_NORMAL v1 = { u1.x, u1.y, u1.z, normal, (float)i / n, (float)j / n };
            TEXTURE_VERTEX_WITH_NORMAL v2 = { u2.x, u2.y, u2.z, normal, (float)(i + 1) / n, (float)j / n };
            TEXTURE_VERTEX_WITH_NORMAL v3 = { u3.x, u3.y, u3.z, normal, (float)i / n, (float)(j + 1) / n };
            TEXTURE_VERTEX_WITH_NORMAL v4 = { u4.x, u4.y, u4.z, normal, (float)(i + 1) / n, (float)(j + 1) / n };

            vertices.push_back(v1);
            vertices.push_back(v2);
            vertices.push_back(v3);

            vertices.push_back(v3);
            vertices.push_back(v2);
            vertices.push_back(v4);
        }
    }
    const UINT width = 256;
    const UINT height = 256;
    IDirect3DTexture9* prevTexture = NULL;

    D3DXCreateTexture(d3dDevice, width, height, mipmapFilenames.size(), 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &this->pTexture);
    D3DXCreateTexture(d3dDevice, width, height, mipmapFilenames.size(), 0, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &prevTexture);

    for (int i = 0; i < (int) mipmapFilenames.size(); ++i)
    {
        IDirect3DSurface9 *pSurf;
        pTexture->GetSurfaceLevel(i, &pSurf);
        D3DXLoadSurfaceFromFile(pSurf, NULL, NULL, mipmapFilenames[i], NULL, D3DX_DEFAULT, 0, NULL);
        pSurf->Release();
    }

    d3dDevice->UpdateTexture(prevTexture, pTexture);
    pTexture->Release();

    setVertices(vertices);
}